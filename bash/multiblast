#!/bin/bash

### Written by Andrey Rozenberg (jaera at yandex.com), Ruhr-Universit√§t Bochum

### This program is free software: you can redistribute it and/or modify
### it under the terms of the GNU General Public License as published by
### the Free Software Foundation, either version 3 of the License, or
### (at your option) any later version.

### This program is distributed in the hope that it will be useful,
### but WITHOUT ANY WARRANTY; without even the implied warranty of
### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
### GNU General Public License for more details.

### You should have received a copy of the GNU General Public License
### along with this program.  If not, see <http://www.gnu.org/licenses/>.

timestart=$(date +"%s")

die() {
	echo $1 >&2
	exit 1
}

trap 'killall' EXIT
killall() {
	trap '' INT TERM
	kill -TERM 0
	wait
	echo
	exit
}

## test whether the command is correct
[[ "$1" =~ blast* ]] || die "Not a blast program '$1'"
command -v "$1" >/dev/null 2>&1 || die "'$1' not found"

num_threads=4
out=""

## grasp the -query argument to replace it with own pipe
for ((j=$#;j>0;j--)); do
	case "${!j}" in
		'-query' | '-num_threads' | '-out' )
			i=$((j-1))
			k=$((j+1))
			l=$((j+2))
			opt=${!j//-/}
			eval $opt=\${!k}
			set -- "${@:1:i}" "${@:l}"
		;;
	esac
done

## check the num_threads and availability of the paths
[[ "$num_threads" =~ ^[1-9][0-9]*$ ]] || die "-num_threads is expected to be a positive number"
[ -f "$query" ]                       || die 'Input file not found'
if [ -z "$out" ]; then
	echo "Attention: no output file specified, the output will be printed to stdout in the end of the run" >&2
else
	printf "" > "$out" || die 'Output file not available'
fi

# build the command
cmd=""
for ((j=1;j<=$#;j++)); do
	case "${!j}" in
		*\ * )
			cmd+=" \"${!j}\""
					;;
		*)
			cmd+=" ${!j}"
	esac
done
cmd+=" -num_threads 1"

## calculate the size of individual query
n=$(awk '/^>/{n++}END{print n}' "$query")
((n>0)) || die 'Input file is empty'
block=$((n/num_threads))
echo "The chosen block size is $block sequences" >&2

timeparse=$(date +"%s")
echo 'Spent '$((timeparse-timestart))' sec on parsing' >&2

## create the temporary files
for ((i=1;i<=num_threads;i++)); do
	if [ -z "$out" ]; then
		out_tmp=$(mktemp -t tmp.XXXXXXXXXX)
	else
		out_tmp="$out.$i"
		[ -s "$out_tmp" ] && die "$out_tmp already exists: rename or relocate it first"
	fi
	out_files[$i]=$out_tmp
done

bar='===================================================================================================='
blk='                                                                                                    '

echo >&2
echo "Temporary output files:" >&2
echo ${out_files[@]} >&2
echo >&2
echo "Records consumed:" >&2

progformat='[%.*s%.*s] %d %%\r'

printf "$progformat" 100 "$blk" >&2

## launch the blast tasks in the background
## individual sequences are piped to blast

beg=0
for ((i=1;i<num_threads;i++)); do
	end=$((block*i))
	$cmd -out ${out_files[$i]} -query <(awk -v beg=$beg -v end=$end '/^>/{n++}n>end{exit}n>beg' "$query") &
	beg=$end
done

ival=$((block/100))
((ival==0)) && ival=1

## one of the processes will also monitor the number of the consumed sequences

$cmd -out ${out_files[$num_threads]} -query <(awk \
	-v block=$block -v beg=$beg -v ival=$ival -v bar=" '$bar' " -v blk=" '$blk' " -v progprintf="printf '$progformat' " '
		BEGIN { k=100/block; b=beg*k }
		/^>/{n++}n<=beg{next}{print;p=sprintf("%d",n*k-b)}n%ival==0&&p-pold>.1{pold=p;r=100-p;system(progprintf p bar r blk p " >&2")}
	' "$query") &

wait

printf "$progformat\n" 100 "$bar" 100 >&2

echo >&2
echo >&2

timeblast=$(date +"%s")
echo 'Spent '$((timeblast-timeparse))' sec to do the blast' >&2

prefix="rows in the output file"
if [ ! -z "$out" ]; then
	rows=$(cat ${out_files[@]} | tee "$out" | wc -l && rm ${out_files[@]})
	echo "$rows $prefix" >&2
else
	cat ${out_files[@]} | tee >(wc -l | { read rows; echo "$rows $prefix" >&2; }) && rm ${out_files[@]}
fi

timeend=$(date +"%s")

echo 'Spent '$((timeend-timeblast))' sec to do the rest' >&2
